#!/bin/bash
## Deploy SSO project inside an existing services tenancy
##
## Must be ran as cluster admin user if SSO 7.1 templates haven't already been imported
## 
## Must be provided with three keystore with correct keys inside of them
## Script does some prework to import SSO7.1 images which may error if it has already been done previously
##
## Args (all required): 
##  project_name	${PROJECTNAME}	- project to deploy SSO into
##  domain_name		${DOMAIN_NAME}  - full domainname for secure sso access - enter "default" for autogenerated name
##  https_keystore	${SSO_HTTPS_KS}	- full path - recommended is sso-https.jks - contains "sso-https-key" cert and the ca (and any intermediate)
##  jgroups_keystore	${JGROUPS_KS}	- full path - recommended is jgroups.jceks - contains a security key called "jgroups"
##  truststore_keystore ${TRUSTSTORE}	- full path - recommended is truststore.jks - contains the ca "ca.crt"
##  keystore_password	${KSPASSWORD}	- the passwords set on all three keystores and certs (sso-https.jks truststore.jks jgroups.jceks)

# Parse command-line options
if [ "$#" -ne 6 ]; then
	echo "${0} - Deploy Red Hat SSO into an existing services OpenShift Tenancy"
    	echo "You must enter exactly 6 command line arguments"
	echo ""
	echo "Usage:"
	echo "${0} <project_name> <domain_name> <https_keystore> <jgroups_keystore> <truststore_keystore> <keystore_password>"
	echo ""
	echo "project_name		- project to deploy SSO into (will be created if not already existing)
domain_name		- full domainname for secure sso access - enter "default" for autogenerated name
https_keystore 		- full path - recommended is sso-https.jks - contains 'sso-https-key' cert and the ca (and any intermediate)
jgroups_keystore	- full path - recommended is jgroups.jceks - contains a security key called 'jgroups'
truststore_keystore	- full path - recommended is truststore.jks - contains the ca 'ca.crt'
keystore_password	- the passwords set on all three keystores and certs (sso-https.jks truststore.jks jgroups.jceks)
"

	echo "Must be run by cluster admin user if importing of SSO 7.1 images is required"
	echo "SSO project will be created if it doesn't exist"
	echo ""
	exit 1
fi

PROJECTNAME=$1
DOMAIN_NAME=$2
SSO_HTTPS_KS=$3
JGROUPS_KS=$4
TRUSTSTORE=$5
KSPASSWORD=$6

# Constants
#WORKINGDIR=/var/tmp/${PROJECTNAME}
#mkdir -p ${WORKINGDIR}
#cd ${WORKINGDIR}

#Check if SSO 7.1 image exists, if not - add the images
oc describe template sso71-postgresql-persistent -n openshift > /dev/null 2>1
if [ $? -ne 0 ]
then

	## Enable new (7.1) SSO templates
	# update the core set of OpenShift image streams in the openshift project
	oc create -n openshift -f https://raw.githubusercontent.com/jboss-openshift/application-templates/ose-v1.3.7/jboss-image-streams.json 	# Generates "AlreadyExists" errors
	oc replace -n openshift -f https://raw.githubusercontent.com/jboss-openshift/application-templates/ose-v1.3.7/jboss-image-streams.json 	# Generates "AlreadyExists" errors

	# Import the RH-SSO for OpenShift 7.1 templates
	for template in sso71-https.json sso71-mysql-persistent.json sso71-mysql.json sso71-postgresql-persistent.json sso71-postgresql.json
	do
	  oc create -n openshift -f https://raw.githubusercontent.com/jboss-openshift/application-templates/ose-v1.3.7/sso/${template}
	done

	# Install the RH-SSO for OpenShift 7.1 image streams in the openshift project
	oc -n openshift import-image redhat-sso71-openshift
fi	


## Create project
oc new-project ${PROJECTNAME}	# Just let it fail if project already exists
oc project ${PROJECTNAME}	# Switch to project incase it already exists

## Create service account
oc create serviceaccount sso-service-account

## Add permissions
oc policy add-role-to-user view system:serviceaccount:${PROJECTNAME}:sso-service-account

## Create two secrets containing keystores
oc secret new sso-ssl-secret ${SSO_HTTPS_KS} ${TRUSTSTORE}
oc secret new sso-jgroups-secret ${JGROUPS_KS}

oc secrets link sso-service-account sso-jgroups-secret sso-ssl-secret

## Trim the filenames of the keystores (since there are no directories inside secrets)
SSO_HTTPS_KS=`echo ${SSO_HTTPS_KS} | awk -F "/" '{print $NF}'`
JGROUPS_KS=`echo ${JGROUPS_KS} | awk -F "/" '{print $NF}'`
TRUSTSTORE=`echo ${TRUSTSTORE} | awk -F "/" '{print $NF}'`

## Check if default domainname is wanted
if [ $DOMAIN_NAME = "default" ]
then
	DOMAIN_NAME=""
fi

## Create SSO app
oc new-app sso71-postgresql-persistent  \
	-p DB_DATABASE=root                              \
	-p SERVICE_ACCOUNT_NAME=sso-service-account      \
	-p HOSTNAME_HTTPS=${DOMAIN_NAME}		\
	-p HTTPS_SECRET=sso-ssl-secret                   \
	-p HTTPS_KEYSTORE=${SSO_HTTPS_KS}                  \
	-p HTTPS_KEYSTORE_TYPE=JKS                       \
	-p HTTPS_NAME=sso-https-key                      \
	-p HTTPS_PASSWORD=${KSPASSWORD}                   \
	-p JGROUPS_ENCRYPT_SECRET=sso-jgroups-secret     \
	-p JGROUPS_ENCRYPT_NAME=jgroups                  \
	-p JGROUPS_ENCRYPT_KEYSTORE=${JGROUPS_KS}		 \
	-p JGROUPS_ENCRYPT_PASSWORD=${KSPASSWORD}         \
	-p IMAGE_STREAM_NAMESPACE=openshift              \
    -p SSO_TRUSTSTORE=${TRUSTSTORE}                \
    -p SSO_TRUSTSTORE_PASSWORD=${KSPASSWORD}          \
    -p SSO_TRUSTSTORE_SECRET=sso-ssl-secret

## Delete non-secure route and service
oc delete route sso
oc delete service sso
